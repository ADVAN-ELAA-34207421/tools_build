/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.builder.resources;

import com.android.annotations.NonNull;
import com.android.resources.FolderTypeRelationship;
import com.android.resources.ResourceConstants;
import com.android.resources.ResourceFolderType;
import com.android.resources.ResourceType;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.io.File;
import java.io.IOException;
import java.lang.Override;
import java.lang.String;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;

/**
 * Represents a set of resources.
 *
 * The resources can be coming from multiple source folders. Duplicates are detected (either
 * from the same source folder -- same resource in values files -- or across the source folders.
 *
 * Each source folders is considered to be at the same level. To use overlays, a
 * {@link ResourceMerger} must be used.
 *
 * Creating the set and adding folders does not load the data.
 * The data can be loaded from the files, or from a blob which is generated by the set itself.
 *
 * Upon loading the data from the blob, the data can be updated with fresher files. Each resource
 * that is updated is flagged as such, in order to manage incremental update.
 *
 * Writing/Loading the blob is not done through this class directly, but instead through the
 * {@link ResourceMerger} which contains ResourceSet objects.
 */
public class ResourceSet implements SourceSet, ResourceMap {

    private static final String NODE_SOURCE = "source";
    private static final String ATTR_CONFIG = "config";
    private static final String ATTR_PATH = "path";
    private static final String NODE_FILE = "file";
    private static final String ATTR_QUALIFIER = "qualifiers";
    private static final String ATTR_TYPE = "type";
    private static final String ATTR_NAME = "name";

    private final String mConfigName;

    /**
     * List of source files. The may not have been loaded yet.
     */
    private final List<File> mSourceFiles = Lists.newArrayList();

    /**
     * The key is the {@link com.android.builder.resources.Resource#getKey()}.
     * This is a multimap to support moving a resource from one file to another (values file)
     * during incremental update.
     */
    private final ListMultimap<String, Resource> mItems = ArrayListMultimap.create();

    /**
     * Map of source files to ResourceFiles. This is a multimap because the key is the source
     * file/folder, not the
     * File for the resource file itself.
     */
    private final ListMultimap<File, ResourceFile> mSourceFileToResourceFilesMap = ArrayListMultimap.create();
    /**
     * Map from a File to its ResourceFile.
     */
    private final Map<File, ResourceFile> mResourceFileMap = Maps.newHashMap();

    /**
     * Creates a resource set with a given configName. The name is used to identify the set
     * across sessions.
     *
     * @param configName the name of the config this set is associated with.
     */
    public ResourceSet(String configName) {
        mConfigName = configName;
    }

    /**
     * Adds a collection of source files.
     * @param files the source files to add.
     */
    public void addSources(Collection<File> files) {
        mSourceFiles.addAll(files);
    }

    /**
     * Adds a new source file
     * @param file the source file.
     */
    public void addSource(File file) {
        mSourceFiles.add(file);
    }

    /**
     * Get the list of source files.
     * @return the source files.
     */
    @NonNull
    @Override
    public List<File> getSourceFiles() {
        return mSourceFiles;
    }

    /**
     * Returns the config name.
     * @return the config name.
     */
    public String getConfigName() {
        return mConfigName;
    }

    /**
     * Returns a matching Source file that contains a given file.
     *
     * "contains" means that the source file/folder is the root folder
     * of this file. The folder and/or file doesn't have to exist.
     *
     * @param file the file to search for
     * @return the Source file or null if no match is found.
     */
    @Override
    public File findMatchingSourceFile(File file) {
        for (File sourceFile : mSourceFiles) {
            if (sourceFile.equals(file)) {
                return sourceFile;
            } else if (sourceFile.isDirectory()) {
                String sourcePath = sourceFile.getAbsolutePath() + File.separator;
                if (file.getAbsolutePath().startsWith(sourcePath)) {
                    return sourceFile;
                }
            }
        }

        return null;
    }

    /**
     * Returns the number of resources.
     * @return the number of resources.
     *
     * @see ResourceMap
     */
    @Override
    public int size() {
        // returns the number of keys, not the size of the multimap which would include duplicate
        // Resource objects.
        return mItems.keySet().size();
    }

    /**
     * Returns whether the set is empty of resources.
     * @return true if the set contains no resources.
     */
    public boolean isEmpty() {
        return mItems.isEmpty();
    }

    /**
     * Returns a map of the resources.
     * @return a map of items.
     *
     * @see ResourceMap
     */
    @NonNull
    @Override
    public ListMultimap<String, Resource> getResourceMap() {
        return mItems;
    }

    /**
     * Loads the resource set from the file its source folder contains.
     *
     * All loaded resources are set to TOUCHED. This is so that after loading the resources from
     * the files, they can be written directly (since touched force them to be written).
     *
     * This also checks for duplicates resources.
     *
     * @throws DuplicateResourceException
     * @throws IOException
     */
    public void loadFromFiles() throws DuplicateResourceException, IOException {
        for (File file : mSourceFiles) {
            if (file.isDirectory()) {
                readSourceFolder(file);

            } else if (file.isFile()) {
                // TODO support resource bundle
            }
        }
        checkItems();
    }

    /**
     * Appends the resourceSet to a given DOM object.
     *
     * @param resourceSetNode the root node for this resource set.
     * @param document The root XML document
     */
    void appendToXml(Node resourceSetNode, Document document) {
        // add the config name attribute
        NodeUtils.addAttribute(document, resourceSetNode, null, ATTR_CONFIG, mConfigName);

        // add the source files.
        // we need to loop on the source files themselves and not the map to ensure we
        // write empty resourceSets
        for (File sourceFile : mSourceFiles) {

            // the node for the source and its path attribute
            Node sourceNode = document.createElement(NODE_SOURCE);
            resourceSetNode.appendChild(sourceNode);
            NodeUtils.addAttribute(document, sourceNode, null, ATTR_PATH,
                    sourceFile.getAbsolutePath());

            Collection<ResourceFile> resourceFiles = mSourceFileToResourceFilesMap.get(sourceFile);

            for (ResourceFile resourceFile : resourceFiles) {
                // the node for the file and its path and qualifiers attribute
                Node fileNode = document.createElement(NODE_FILE);
                sourceNode.appendChild(fileNode);
                NodeUtils.addAttribute(document, fileNode, null, ATTR_PATH,
                        resourceFile.getFile().getAbsolutePath());
                NodeUtils.addAttribute(document, fileNode, null, ATTR_QUALIFIER,
                        resourceFile.getQualifiers());

                if (resourceFile.getType() == ResourceFile.FileType.MULTI) {
                    for (Resource item : resourceFile.getItems()) {
                        Node adoptedNode = NodeUtils.adoptNode(document, item.getValue());
                        fileNode.appendChild(adoptedNode);
                    }
                } else {
                    Resource item = resourceFile.getItem();
                    NodeUtils.addAttribute(document, fileNode, null, ATTR_TYPE,
                            item.getType().getName());
                    NodeUtils.addAttribute(document, fileNode, null, ATTR_NAME, item.getName());
                }
            }
        }
    }

    /**
     * Creates a new ResourceSet from an XML node that was created with
     * {@link #appendToXml(org.w3c.dom.Node, org.w3c.dom.Document)}
     *
     * @param resourceSetNode the node to read from.
     * @return a new ResourceSet object or null.
     */
    static ResourceSet createFromXml(Node resourceSetNode) {
        // get the config name
        Attr configNameAttr = (Attr) resourceSetNode.getAttributes().getNamedItem(ATTR_CONFIG);
        if (configNameAttr == null) {
            return null;
        }

        // create the ResourceSet that will be filled with the content of the XML.
        ResourceSet resourceSet = new ResourceSet(configNameAttr.getValue());

        // loop on the source nodes
        NodeList sourceNodes = resourceSetNode.getChildNodes();
        for (int i = 0, n = sourceNodes.getLength(); i < n; i++) {
            Node sourceNode = sourceNodes.item(i);

            if (sourceNode.getNodeType() != Node.ELEMENT_NODE ||
                    !NODE_SOURCE.equals(sourceNode.getLocalName())) {
                continue;
            }

            Attr pathAttr = (Attr) sourceNode.getAttributes().getNamedItem(ATTR_PATH);
            if (pathAttr == null) {
                continue;
            }

            File sourceFolder = new File(pathAttr.getValue());
            resourceSet.mSourceFiles.add(sourceFolder);

            // now loop on the files inside the source folder.
            NodeList fileNodes = sourceNode.getChildNodes();
            for (int j = 0, m = fileNodes.getLength(); j < m; j++) {
                Node fileNode = fileNodes.item(j);

                if (fileNode.getNodeType() != Node.ELEMENT_NODE ||
                        !NODE_FILE.equals(fileNode.getLocalName())) {
                    continue;
                }

                pathAttr = (Attr) fileNode.getAttributes().getNamedItem(ATTR_PATH);
                if (pathAttr == null) {
                    continue;
                }

                Attr qualifierAttr = (Attr) fileNode.getAttributes().getNamedItem(ATTR_QUALIFIER);
                String qualifier = qualifierAttr != null ? qualifierAttr.getValue() : null;

                Attr typeAttr = (Attr) fileNode.getAttributes().getNamedItem(ATTR_TYPE);
                if (typeAttr == null) {
                    // multi res file
                    List<Resource> resourceList = Lists.newArrayList();

                    // loop on each node that represent a resource
                    NodeList resNodes = fileNode.getChildNodes();
                    for (int iii = 0, nnn = resNodes.getLength(); iii < nnn; iii++) {
                        Node resNode = resNodes.item(iii);

                        if (resNode.getNodeType() != Node.ELEMENT_NODE) {
                            continue;
                        }

                        Resource r = ValueResourceParser.getResource(resNode);
                        if (r != null) {
                            resourceList.add(r);
                        }
                    }

                    ResourceFile resourceFile = new ResourceFile(new File(pathAttr.getValue()),
                            resourceList, qualifier);
                    resourceSet.addResourceFile(sourceFolder, resourceFile);

                    for (Resource item : resourceList) {
                        resourceSet.mItems.put(item.getKey(), item);
                    }

                } else {
                    // single res file
                    ResourceType type = ResourceType.getEnum(typeAttr.getValue());
                    if (type == null) {
                        continue;
                    }

                    Attr nameAttr = (Attr) fileNode.getAttributes().getNamedItem(ATTR_NAME);
                    if (nameAttr == null) {
                        continue;
                    }

                    Resource item = new Resource(nameAttr.getValue(), type, null);
                    ResourceFile resourceFile = new ResourceFile(new File(pathAttr.getValue()),
                            item, qualifier);

                    resourceSet.addResourceFile(sourceFolder, resourceFile);
                    resourceSet.mItems.put(item.getKey(), item);
                }
            }
        }

        return resourceSet;
    }

    /**
     * Reads the content of a resource folders and loads the resources.
     * @param sourceFolder the source folder to load the resources from.
     *
     * @throws DuplicateResourceException
     * @throws IOException
     */
    private void readSourceFolder(File sourceFolder)
            throws DuplicateResourceException, IOException {
        File[] folders = sourceFolder.listFiles();
        if (folders != null) {
            for (File folder : folders) {
                if (folder.isDirectory()) {
                    parseFolder(sourceFolder, folder);
                }
            }
        }
    }

    /**
     * temp structure containing a qualifier string and a {@link ResourceType}.
     */
    private static class FolderData {
        String qualifiers = null;
        ResourceType type = null;
    }

    /**
     * Returns a FolderData for the given folder
     * @param folder the folder.
     * @return the FolderData object.
     */
    @NonNull
    private static FolderData getFolderData(File folder) {
        FolderData fd = new FolderData();

        String folderName = folder.getName();
        int pos = folderName.indexOf(ResourceConstants.RES_QUALIFIER_SEP);
        ResourceFolderType folderType;
        if (pos != -1) {
            folderType = ResourceFolderType.getTypeByName(folderName.substring(0, pos));
            fd.qualifiers = folderName.substring(pos + 1);
        } else {
            folderType = ResourceFolderType.getTypeByName(folderName);
        }

        if (folderType != ResourceFolderType.VALUES) {
            fd.type = FolderTypeRelationship.getRelatedResourceTypes(folderType).get(0);
        }

        return fd;
    }

    /**
     * Reads the content of a typed resource folder (sub folder to the root of res folder), and
     * loads the resources from it.
     *
     * @param sourceFolder the main res folder
     * @param folder the folder to read.
     *
     * @throws IOException
     */
    private void parseFolder(File sourceFolder, File folder)
            throws IOException {
        // get the type.
        FolderData folderData = getFolderData(folder);

        // get the files
        File[] files = folder.listFiles();
        if (files != null && files.length > 0) {
            for (File file : files) {
                if (folderData.type != null) {
                    Resource item = handleSingleResFile(sourceFolder,
                            folderData.qualifiers, folderData.type, file);
                    item.setTouched();
                } else {
                    Collection<Resource> items = handleMultiResFile(sourceFolder,
                            folderData.qualifiers, file);
                    for (Resource item : items) {
                        item.setTouched();
                    }
                }
            }
        }
    }

    /**
     * Handles a single resource file (ie not located in "values") and create a Resource from it.
     *
     * @param sourceFolder the top res folder for the file
     * @param qualifiers the qualifiers associated with the file
     * @param type the ResourceType read from the parent folder name
     * @param file the single resource file
     * @return a Resource object
     */
    @NonNull
    private Resource handleSingleResFile(File sourceFolder, String qualifiers,
                                         ResourceType type, File file) {
        int pos;// get the resource name based on the filename
        String name = file.getName();
        pos = name.indexOf('.');
        name = name.substring(0, pos);

        Resource item = new Resource(name, type, null);
        ResourceFile resourceFile = new ResourceFile(file, item, qualifiers);
        addResourceFile(sourceFolder, resourceFile);

        mItems.put(item.getKey(), item);

        return item;
    }

    /**
     * Handles a multi res file (in a "values" folder) and create Resource object from it.
     *
     * @param sourceFolder the top res folder for the file
     * @param qualifiers the qualifiers associated with the file
     * @param file the single resource file
     * @return a list of created Resource objects.
     *
     * @throws IOException
     */
    @NonNull
    private Collection<Resource> handleMultiResFile(File sourceFolder, String qualifiers, File file)
            throws IOException {
        ValueResourceParser parser = new ValueResourceParser(file);
        List<Resource> items = parser.parseFile();

        ResourceFile resourceFile = new ResourceFile(file, items, qualifiers);
        addResourceFile(sourceFolder, resourceFile);

        for (Resource item : items) {
            mItems.put(item.getKey(), item);
        }

        return items;
    }

    /**
     * Adds a new ResourceFile to this.
     *
     * @param sourceFile the parent source file.
     * @param resourceFile the ResourceFile
     */
    private void addResourceFile(File sourceFile, ResourceFile resourceFile) {
        mSourceFileToResourceFilesMap.put(sourceFile, resourceFile);
        mResourceFileMap.put(resourceFile.getFile(), resourceFile);
    }

    /**
     * Checks for duplicate resources across all source files.
     *
     * @throws DuplicateResourceException if a duplicated item is found.
     */
    void checkItems() throws DuplicateResourceException {
        // check a list for duplicate, ignoring removed items.
        for (Map.Entry<String, Collection<Resource>> entry : mItems.asMap().entrySet()) {
            Collection<Resource> items = entry.getValue();

            // there can be several version of the same key if some are "removed"
            Resource lastItem = null;
            for (Resource item : items) {
                if (!item.isRemoved()) {
                    if (lastItem == null) {
                        lastItem = item;
                    } else {
                        throw new DuplicateResourceException(item, lastItem);
                    }
                }
            }
        }
    }

    /**
     * Update the ResourceSet with a given file.
     *
     * @param sourceFolder the sourceFile containing the changedFile
     * @param changedFile The changed file
     * @param fileStatus the change state
     * @return true if the set was properly updated, false otherwise
     */
    public boolean updateWith(File sourceFolder, File changedFile, FileStatus fileStatus)
            throws IOException {
        switch (fileStatus) {
            case CHANGED:
                FolderData folderData = getFolderData(changedFile.getParentFile());
                ResourceFile resourceFile = mResourceFileMap.get(changedFile);

                if (folderData.type != null) {
                    // single res file
                    resourceFile.getItem().setTouched();
                } else {
                    // multi res. Need to parse the file and compare the items one by one.
                    ValueResourceParser parser = new ValueResourceParser(changedFile);
                    List<Resource> parsedItems = parser.parseFile();

                    Map<String, Resource> oldItems = Maps.newHashMap(resourceFile.getItemMap());

                    Map<String, Resource> newItems  = Maps.newHashMap();

                    // create a fake ResourceFile to be able to call resource.getKey();
                    // It's ok because we never use this instance anyway.
                    ResourceFile fakeResourceFile = new ResourceFile(changedFile, parsedItems,
                            resourceFile.getQualifiers());

                    for (Resource newItem : parsedItems) {
                        String newKey = newItem.getKey();
                        Resource oldItem = oldItems.get(newKey);

                        if (oldItem == null) {
                            // this is a new item
                            newItems.put(newKey, newItem.setTouched());
                        } else {
                            // remove it from the list of oldItems (this is to detect deletion)
                            //noinspection SuspiciousMethodCalls
                            oldItems.remove(oldItem.getKey());

                            // now compare the items
                            if (!oldItem.compareValueWith(newItem)) {
                                // if the values are different, take the values from the newItems
                                // and update the old item status.

                                oldItem.setValue(newItem);
                            }
                        }
                    }

                    // at this point oldItems is left with the deleted items.
                    // just update their status to removed.
                    for (Resource deletedItem : oldItems.values()) {
                        deletedItem.setRemoved();
                    }

                    // Now we need to add the new items to the resource file and the main map
                    resourceFile.addItems(newItems.values());
                    for (Map.Entry<String, Resource> entry : newItems.entrySet()) {
                        mItems.put(entry.getKey(), entry.getValue());
                    }
                }

                return true;
            case NEW:
                folderData = getFolderData(changedFile.getParentFile());

                if (folderData.type != null) {
                    Resource item = handleSingleResFile(sourceFolder, folderData.qualifiers,
                            folderData.type, changedFile);
                    item.setTouched();
                } else {
                    Collection<Resource> items = handleMultiResFile(sourceFolder,
                            folderData.qualifiers, changedFile);
                    for (Resource item : items) {
                        item.setTouched();
                    }
                }

                return true;
            case REMOVED:
                resourceFile = mResourceFileMap.get(changedFile);

                // flag all resource items are removed
                for (Resource item : resourceFile.getItems()) {
                    item.setRemoved();
                }
                return true;
        }

        return false;
    }

    @Override
    public String toString() {
        return Arrays.toString(mSourceFiles.toArray());
    }
}
